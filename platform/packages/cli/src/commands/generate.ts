/**
 * Generate command - Generate code from Blueprint
 */

import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';
import ora from 'ora';
import yaml from 'yaml';
import { validateBlueprint } from '@appkod/contracts';

interface GenerateOptions {
  input: string;
  output: string;
  watch: boolean;
}

export async function generateCommand(
  blueprint?: string,
  options?: GenerateOptions
): Promise<void> {
  const inputFile = blueprint || options?.input || 'blueprint.yaml';
  const outputDir = options?.output || './generated';

  console.log(chalk.bold('\nüöÄ Appkod Code Generator\n'));
  console.log(chalk.gray(`  Input:  ${inputFile}`));
  console.log(chalk.gray(`  Output: ${outputDir}\n`));

  // Check if Blueprint file exists
  if (!fs.existsSync(inputFile)) {
    console.error(chalk.red(`‚ùå Blueprint file not found: ${inputFile}`));
    process.exit(1);
  }

  const spinner = ora('Loading Blueprint...').start();

  try {
    // Load Blueprint
    const blueprintContent = fs.readFileSync(inputFile, 'utf-8');
    const ext = path.extname(inputFile);
    let blueprintData;

    if (ext === '.yaml' || ext === '.yml') {
      blueprintData = yaml.parse(blueprintContent);
    } else if (ext === '.json') {
      blueprintData = JSON.parse(blueprintContent);
    } else {
      throw new Error(`Unsupported file type: ${ext}`);
    }

    spinner.text = 'Validating Blueprint...';

    // Validate Blueprint
    const validation = validateBlueprint(blueprintData);

    if (!validation.success) {
      spinner.fail(chalk.red('‚ùå Blueprint validation failed'));
      console.log(chalk.red('\nValidation errors:'));
      validation.errors.errors.forEach((error: any) => {
        console.log(chalk.red(`  - ${error.path.join('.')}: ${error.message}`));
      });
      process.exit(1);
    }

    spinner.succeed(chalk.green('‚úÖ Blueprint validated'));

    // Generate code
    spinner.start('Generating code...');

    // Call Python codegen engine via subprocess
    // For Phase 0, we create placeholder structure

    const { database, api, ui, name } = validation.data;

    // Create output structure
    fs.ensureDirSync(path.join(outputDir, 'prisma'));
    fs.ensureDirSync(path.join(outputDir, 'api'));
    fs.ensureDirSync(path.join(outputDir, 'web/app'));

    // Generate placeholder files (In production, call Python codegen)
    const files = [
      {
        path: 'prisma/schema.prisma',
        content: generatePrismaPlaceholder(database, name),
      },
      {
        path: 'api/models.py',
        content: generateModelsPlaceholder(database, name),
      },
      {
        path: 'api/routes.py',
        content: generateRoutesPlaceholder(api, name),
      },
      {
        path: 'README.md',
        content: generateReadmePlaceholder(name),
      },
    ];

    for (const file of files) {
      const filePath = path.join(outputDir, file.path);
      fs.ensureDirSync(path.dirname(filePath));
      fs.writeFileSync(filePath, file.content);
    }

    // Generate UI pages
    for (const page of ui.pages) {
      const pagePath = page.path === '/' ? 'page' : `${page.path.slice(1)}/page`;
      const filePath = path.join(outputDir, 'web/app', `${pagePath}.tsx`);
      fs.ensureDirSync(path.dirname(filePath));
      fs.writeFileSync(filePath, generatePagePlaceholder(page));
    }

    spinner.succeed(chalk.green(`‚úÖ Code generated in ${outputDir}`));

    // Summary
    console.log(chalk.bold('\nüì¶ Generated Files:\n'));
    console.log(chalk.cyan('  üìÅ prisma/'));
    console.log(chalk.gray('     ‚îî‚îÄ‚îÄ schema.prisma'));
    console.log(chalk.cyan('  üìÅ api/'));
    console.log(chalk.gray('     ‚îú‚îÄ‚îÄ models.py'));
    console.log(chalk.gray('     ‚îî‚îÄ‚îÄ routes.py'));
    console.log(chalk.cyan('  üìÅ web/app/'));

    ui.pages.forEach((page: any) => {
      const pagePath = page.path === '/' ? 'page.tsx' : `${page.path.slice(1)}/page.tsx`;
      console.log(chalk.gray(`     ‚îî‚îÄ‚îÄ ${pagePath}`));
    });

    console.log(chalk.bold('\n‚ú® Next steps:\n'));
    console.log(chalk.gray(`  1. cd ${outputDir}`));
    console.log(chalk.gray('  2. npm install'));
    console.log(chalk.gray('  3. npx prisma generate'));
    console.log(chalk.gray('  4. npm run dev\n'));

    if (options?.watch) {
      console.log(chalk.yellow('üëÄ Watching for Blueprint changes...'));
      // TODO: Implement watch mode
    }
  } catch (error: any) {
    spinner.fail(chalk.red('‚ùå Code generation failed'));
    console.error(chalk.red(`\nError: ${error.message}`));
    process.exit(1);
  }
}

function generatePrismaPlaceholder(database: any, name: string): string {
  return `// Auto-generated Prisma schema for ${name}
// Generated by Appkod CLI

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// TODO: Generate models from Blueprint.database
// Run \`appkod generate\` to regenerate
`;
}

function generateModelsPlaceholder(database: any, name: string): string {
  return `"""Auto-generated SQLModel models for ${name}"""
# Generated by Appkod CLI

from sqlmodel import SQLModel, Field
from uuid import UUID

# TODO: Generate models from Blueprint.database
# Run \`appkod generate\` to regenerate
`;
}

function generateRoutesPlaceholder(api: any, name: string): string {
  return `"""Auto-generated API routes for ${name}"""
# Generated by Appkod CLI

from fastapi import APIRouter

router = APIRouter()

# TODO: Generate routes from Blueprint.api
# Run \`appkod generate\` to regenerate
`;
}

function generatePagePlaceholder(page: any): string {
  return `// Auto-generated Next.js page
// Generated by Appkod CLI

'use client';

export default function ${toPascalCase(page.title.replace(/\s+/g, ''))}Page() {
  return (
    <div className="container mx-auto p-6">
      <h1 className="text-3xl font-bold">${page.title}</h1>
      {/* TODO: Generate components from Blueprint.ui */}
    </div>
  );
}
`;
}

function generateReadmePlaceholder(name: string): string {
  return `# ${name}

Auto-generated by Appkod CLI

## Getting Started

\`\`\`bash
# Install dependencies
npm install

# Generate Prisma client
npx prisma generate

# Run database migrations
npx prisma migrate dev

# Start development server
npm run dev
\`\`\`

## Structure

- \`prisma/\` - Database schema
- \`api/\` - FastAPI backend
- \`web/\` - Next.js frontend

## Regenerate

Edit \`blueprint.yaml\` and run:

\`\`\`bash
appkod generate
\`\`\`
`;
}

function toPascalCase(str: string): string {
  return str.replace(/(?:^|\s)\w/g, (match) => match.toUpperCase()).replace(/\s+/g, '');
}
